// File generated by src/generate_types.zig
export type Token = {
	tag: LexerTokenTag;
	start: number;
	end: number;
};

export type LexerTokenTag =
	| "eof"
	| "identifier"
	| "number_literal"
	| "string_literal"
	| "char_literal"
	| "template_string_literal"
	| "comment"
	| "double_pipe"
	| "double_ampersand"
	| "equal"
	| "double_equal"
	| "bang_equal"
	| "r_angle_bracket_equal"
	| "l_angle_bracket_equal"
	| "double_r_angle_bracket"
	| "double_l_angle_bracket"
	| "r_angle_bracket"
	| "l_angle_bracket"
	| "l_parenthesis"
	| "r_parenthesis"
	| "l_brace"
	| "r_brace"
	| "l_bracket"
	| "r_bracket"
	| "comma"
	| "semicolon"
	| "colon"
	| "fat_arrow"
	| "newline"
	| "tab"
	| "double_plus"
	| "double_minus"
	| "double_star"
	| "slash_equal"
	| "star_equal"
	| "plus_equal"
	| "minus_equal"
	| "dot"
	| "double_dot"
	| "double_dot_equal"
	| "ellipsis"
	| "symbol"
	| "bang"
	| "plus"
	| "minus"
	| "star"
	| "slash"
	| "percent"
	| "ampersand"
	| "caret"
	| "pipe"
	| "backslash"
	| "tilde"
	| "keyword_if"
	| "keyword_else"
	| "keyword_for"
	| "keyword_while"
	| "keyword_do"
	| "keyword_inline"
	| "keyword_switch"
	| "keyword_case"
	| "keyword_default"
	| "keyword_break"
	| "keyword_continue"
	| "keyword_return"
	| "keyword_import"
	| "keyword_export"
	| "keyword_module"
	| "keyword_type"
	| "keyword_struct"
	| "keyword_enum"
	| "keyword_union"
	| "keyword_const"
	| "keyword_let"
	| "keyword_var"
	| "keyword_fn"
	| "keyword_function"
	| "keyword_func"
	| "keyword_gen"
	| "keyword_impl"
	| "keyword_trait"
	| "keyword_interface"
	| "keyword_extends"
	| "keyword_implements"
	| "keyword_as"
	| "keyword_in"
	| "keyword_of"
	| "keyword_is"
	| "keyword_match"
	| "keyword_where"
	| "keyword_when"
	| "keyword_then"
	| "keyword_with"
	| "keyword_using"
	| "keyword_defer"
	| "keyword_async"
	| "keyword_await"
	| "keyword_yield"
	| "keyword_throw"
	| "keyword_try"
	| "keyword_catch"
	| "keyword_finally"
	| "keyword_or"
	| "keyword_and"
	| "keyword_not"
	| "keyword_orelse"
	| "keyword_class"
	| "keyword_true"
	| "keyword_false"
	| "keyword_null"
	| "keyword_undefined"
	| "keyword_void"
	| "keyword_bool"
	| "keyword_boolean"
	| "keyword_pub"
	| "keyword_extern"
	| "keyword_number"
	| "keyword_string"
	| "keyword_i32"
	| "keyword_i64"
	| "keyword_f32"
	| "keyword_f64";
export type AstNode = {
	start_token: number;
	end_token: number;
	data:
		| {
				root: {
					list: Array<number>;
				};
		  }
		| {
				add: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				div: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				mod: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				mul: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				pow: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				sub: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				eq: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				gt: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				ge: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				lt: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				le: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				ne: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				and: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				or: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				xor: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				prop_access: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				band: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				bor: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				bshl: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				bshr: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				bxor: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				bnot: {
					node: number;
				};
		  }
		| {
				neg: {
					node: number;
				};
		  }
		| {
				not: {
					node: number;
				};
		  }
		| {
				decrement: {
					node: number;
				};
		  }
		| {
				increment: {
					node: number;
				};
		  }
		| {
				export: {
					node: number;
				};
		  }
		| {
				extern: {
					node: number;
				};
		  }
		| {
				pub: {
					node: number;
				};
		  }
		| {
				assign: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				ty_assign: {
					lhs: number;
					rhs: number;
				};
		  }
		| {
				char_literal: {
					token: number;
				};
		  }
		| {
				false_literal: {
					token: number;
				};
		  }
		| {
				hex_literal: {
					token: number;
				};
		  }
		| {
				identifier: {
					token: number;
				};
		  }
		| {
				number_literal: {
					token: number;
				};
		  }
		| {
				string_literal: {
					token: number;
				};
		  }
		| {
				true_literal: {
					token: number;
				};
		  }
		| {
				ty_boolean: {
					token: number;
				};
		  }
		| {
				ty_number: {
					token: number;
				};
		  }
		| {
				ty_option: {
					token: number;
				};
		  }
		| {
				ty_string: {
					token: number;
				};
		  }
		| {
				ty_void: {
					token: number;
				};
		  }
		| {
				ty_generic: {
					name: number;
					args_list: Array<number>;
				};
		  }
		| {
				const_decl: {
					name: number;
					type: number;
					value: number;
				};
		  }
		| {
				var_decl: {
					name: number;
					type: number;
					value: number;
				};
		  }
		| {
				fn_decl: {
					proto: number;
					body: number;
				};
		  }
		| {
				fn_proto: {
					name: number;
					params_list: Array<number>;
					ret_type: number;
				};
		  }
		| {
				fn_param: {
					name: number;
					type: number;
				};
		  }
		| {
				fn_call: {
					callee: number;
					args_list: Array<number>;
				};
		  }
		| {
				expr: {
					list: Array<number>;
				};
		  }
		| {
				group: {
					node: number;
				};
		  }
		| {
				if_expr: {
					condition: number;
					then_branch: number;
					else_branch: number;
				};
		  }
		| {
				ret_expression: {
					node: number;
				};
		  }
		| {
				block: {
					list: Array<number>;
				};
		  }
		| {
				while_loop: {
					condition: number;
					body: number;
				};
		  }
		| {
				ty_i32: {
					token: number;
				};
		  }
		| {
				ty_i64: {
					token: number;
				};
		  }
		| {
				ty_f32: {
					token: number;
				};
		  }
		| {
				ty_f64: {
					token: number;
				};
		  };
};

export type HirInstruction =
	| {
			fn_decl: {
				name_node: number;
				return_type: number;
				params: number;
				init: null | number;
			};
	  }
	| {
			fn_call: {
				callee: number;
				args_list: Array<number>;
			};
	  }
	| {
			mod_decl: {
				name_node: null | number;
				declarations_list: Array<number>;
			};
	  }
	| {
			param_decl: {
				name_node: number;
				ty: number;
			};
	  }
	| {
			param_get: {
				operand: number;
			};
	  }
	| {
			global_get: {
				operand: number;
			};
	  }
	| {
			global_decl: {
				name_node: number;
				extern: boolean;
				is_fn: boolean;
				visibility: Visibility;
				type: null | number;
				exported: boolean;
				mutable: boolean;
				init: number;
			};
	  }
	| {
			local_get: {
				operand: number;
			};
	  }
	| {
			block: {
				name_node: null | number;
				instructions_list: Array<number>;
			};
	  }
	| {
			inline_block: {
				name_node: null | number;
				instructions_list: Array<number>;
			};
	  }
	| {
			local: {
				name_node: number;
			};
	  }
	| {
			local_set: {
				lhs: number;
				rhs: number;
			};
	  }
	| {
			decl_ref: number;
	  }
	| {
			loop: {
				body: number;
			};
	  }
	| {
			assign: {
				lhs: number;
				rhs: number;
			};
	  }
	| {
			number_literal: number;
	  }
	| {
			ty_number: number;
	  }
	| {
			ty_boolean: number;
	  }
	| {
			undefined_value: null | number;
	  }
	| {
			as: {
				lhs: number;
				rhs: number;
			};
	  }
	| {
			add: {
				lhs: number;
				rhs: number;
			};
	  }
	| {
			sub: {
				lhs: number;
				rhs: number;
			};
	  }
	| {
			mul: {
				lhs: number;
				rhs: number;
			};
	  }
	| {
			div: {
				lhs: number;
				rhs: number;
			};
	  }
	| {
			gt: {
				lhs: number;
				rhs: number;
			};
	  }
	| {
			lt: {
				lhs: number;
				rhs: number;
			};
	  }
	| {
			ge: {
				lhs: number;
				rhs: number;
			};
	  }
	| {
			le: {
				lhs: number;
				rhs: number;
			};
	  }
	| {
			eq: {
				lhs: number;
				rhs: number;
			};
	  }
	| {
			ne: {
				lhs: number;
				rhs: number;
			};
	  }
	| {
			typeof: {
				operand: number;
			};
	  }
	| {
			ret: {
				operand: number;
			};
	  }
	| {
			if_expr: {
				cond: number;
				then_body: number;
				else_body: null | number;
			};
	  }
	| {
			br: {
				operand: number;
			};
	  }
	| {
			ty_i32: number;
	  }
	| {
			ty_i64: number;
	  }
	| {
			ty_f32: number;
	  }
	| {
			ty_f64: number;
	  }
	| {
			debug_var: {
				name_node: number;
				instruction: number;
			};
	  };

export type Visibility = "public" | "private";
